use std::path::PathBuf;

use regex::Regex;

// `crate::graph::NodeDef` has extra class attributes that cannot be generated by
// `pyo3_introspection`. So we patch them in manually from a handwritten stub.
const NODEDEF_CLASS_PATCH: &str = "
class NodeDef:
    Func = tierkreis_core.nodes.NodeDef_Func
    Eval = tierkreis_core.nodes.NodeDef_Eval
    Loop = tierkreis_core.nodes.NodeDef_Loop
    Map = tierkreis_core.nodes.NodeDef_Map
    Const = tierkreis_core.nodes.NodeDef_Const
    IfElse = tierkreis_core.nodes.NodeDef_IfElse
    EagerIfElse = tierkreis_core.nodes.NodeDef_EagerIfElse
    Input = tierkreis_core.nodes.NodeDef_Input
    Output = tierkreis_core.nodes.NodeDef_Output
";

// `crate::graph::NodeStep` has extra class attributes that cannot be generated by
// `pyo3_introspection`. So we patch them in manually from a handwritten stub.
const NODESTEP_CLASS_PATCH: &str = "
class NodeStep:
    Root = tierkreis_core.steps.NodeStep_Root
    Node = tierkreis_core.steps.NodeStep_Node
    Loop = tierkreis_core.steps.NodeStep_Loop
    Map = tierkreis_core.steps.NodeStep_Map
    Exterior = tierkreis_core.steps.NodeStep_Exterior
";

pub fn main() {
    let eq_regex = Regex::new(r"__eq__\(self, /, other: \w+\.\w+").unwrap();
    let ne_regex = Regex::new(r"__ne__\(self, /, other: \w+\.\w+").unwrap();

    // This assumes the package is installed as editable.
    //
    // TODO: perhaps check for venv variable instead?
    let module = pyo3_introspection::introspect_cdylib(
        "./python/tierkreis_core/_tierkreis_core.abi3.so",
        "_tierkreis_core",
    )
    .unwrap();
    let stubs = pyo3_introspection::module_stub_files(&module);

    for (stub_name, stub) in &stubs {
        // The stub file adds types new() methods and not constructors
        //
        // This is technically correct but doesn't play nicely with pyright, so patch them for now.
        let mut patched_stub = stub.replace("__new__(cls", "__init__(self");

        for stub_name in stubs.keys() {
            let module_name = stub_name.file_stem().unwrap().to_str().unwrap();
            patched_stub = patched_stub.replace(
                &format!("import {}", module_name),
                &format!(
                    "import tierkreis_core._tierkreis_core.{} as {}",
                    module_name, module_name
                ),
            );
        }

        if stub_name.file_stem().unwrap().to_str().unwrap() == "graph" {
            // Add an extra import for the handwritten stub.
            patched_stub = patched_stub.replace(
                "import tierkreis_core.aliases",
                "import tierkreis_core.aliases\nimport tierkreis_core.nodes",
            );

            patched_stub = patched_stub.replace("class NodeDef:", NODEDEF_CLASS_PATCH);

            // Extra patches for erroneous typing.Any on properties.

            // Patch nodes on GraphData
            patched_stub = patched_stub.replace(
                "def nodes(self, /) -> typing.Any",
                "def nodes(self, /) -> list[NodeDef]",
            );

            // Patch in_edges on NodeDef
            patched_stub = patched_stub.replace(
                "def in_edges(self, /) -> typing.Any",
                "def in_edges(self, /) -> dict[tierkreis_core.aliases.PortID, identifiers.ValueRef | identifiers.ExteriorRef]",
            );

            // Patch outer_graph on NodeDescription
            patched_stub = patched_stub.replace(
                "def outer_graph(self, /) -> typing.Any",
                "def outer_graph(self, /) -> graph.GraphData | None",
            );

            // Patch outputs on NodeDescription
            patched_stub = patched_stub.replace(
                "def outputs(self, /) -> typing.Any",
                "def outputs(self, /) -> dict[tierkreis_core.aliases.PortID, identifiers.NodeIndex]",
            );
        }

        if stub_name.file_stem().unwrap().to_str().unwrap() == "location" {
            // Add an extra import for the handwritten stub.
            patched_stub = patched_stub.replace(
                "import _typeshed",
                "import _typeshed\nimport tierkreis_core.steps",
            );

            patched_stub = patched_stub.replace("class NodeStep:", NODESTEP_CLASS_PATCH);
        }

        // Python expects the type of the target in __eq__ to actually be object
        let patched_stub = eq_regex.replace_all(&patched_stub, "__eq__(self, /, other: object");

        // Python expects the type of the target in __ne__ to actually be object
        let patched_stub = ne_regex.replace_all(&patched_stub, "__ne__(self, /, other: object");

        let mut path = PathBuf::new();
        path.push("python");
        path.push("tierkreis_core");
        path.push("_tierkreis_core");
        path.push(stub_name);
        std::fs::write(path, &*patched_stub).unwrap();
    }
}
